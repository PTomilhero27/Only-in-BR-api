datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// =====================
// ENUMS
// =====================

enum StallSize {
  SIZE_2X2
  SIZE_3X3
  SIZE_3X6
  TRAILER
  CART // ✅ novo
}

enum StallType {
  OPEN
  CLOSED
  TRAILER
  CART // ✅ novo
}

enum UserRole {
  ADMIN
  EXHIBITOR
}

enum FairStatus {
  ATIVA
  FINALIZADA
  CANCELADA
}

enum PersonType {
  PF
  PJ
}

enum BankAccountType {
  CORRENTE
  POUPANCA
  PAGAMENTO
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

enum AuditEntity {
  FAIR
  USER
  CONTRACT
  PAYMENT
  OWNER_FAIR
  STALL_FAIR
  OWNER_FAIR_PURCHASE
  OWNER_FAIR_PURCHASE_PAYMENT
  OWNER_FAIR_PURCHASE_ADJUSTMENT
}

enum AdjustmentType {
  DISCOUNT
  SURCHARGE
}

/**
 * Status operacional do expositor dentro da feira.
 * Obs.: continua existindo com contratos/pagamentos pois é útil no dashboard.
 */
enum OwnerFairStatus {
  SELECIONADO
  AGUARDANDO_PAGAMENTO
  AGUARDANDO_ASSINATURA
  AGUARDANDO_BARRACAS
  CONCLUIDO
}

/**
 * Status editorial do template de documento (contrato/aditivo).
 */
enum DocumentTemplateStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PasswordTokenType {
  ACTIVATE_ACCOUNT
  RESET_PASSWORD
}

enum OwnerFairPaymentStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

// =====================
// EXCEL TEMPLATES (MVP)
// =====================

enum ExcelTemplateStatus {
  ACTIVE
  INACTIVE
}

enum ExcelCellType {
  TEXT
  BIND
}

enum ExcelValueFormat {
  TEXT
  INT
  MONEY_CENTS
  DATE
  DATETIME
  BOOL
}

enum ExcelDataset {
  // SINGLE
  FAIR_INFO
  FAIR_SUMMARY
  OWNER_INFO
  OWNER_SUMMARY
  STALL_INFO
  STALL_SUMMARY

  // MULTI
  FAIR_EXHIBITORS_LIST
  FAIR_STALLS_LIST
  FAIR_PURCHASES_LIST
  OWNER_FAIRS_LIST
  OWNER_STALLS_LIST
  STALL_FAIRS_LIST
}

enum ExcelTemplateScope {
  FAIR
  FAIR_OWNER
  FAIR_STALL
  OWNER
  STALL
}

enum MapElementType {
  BOOTH_SLOT // slot de barraca (único linkável)
  RECT
  SQUARE
  LINE
  TEXT
  TREE
}

model User {
  id String @id @default(uuid())

  /**
   * Nome exibido do usuário.
   * Para EXHIBITOR pode ficar null (usamos Owner.fullName).
   */
  name String?

  /**
   * E-mail de login (único).
   */
  email String @unique

  /**
   * ✅ Hash da senha.
   * - null => conta ainda não ativada (aguardando definição de senha).
   */
  password String?

  /**
   * Papel principal.
   */
  role UserRole @default(ADMIN)

  /**
   * ✅ Permite admin desativar o acesso sem deletar.
   */
  isActive Boolean @default(true)

  /**
   * ✅ Quando a senha foi definida (ativação concluída).
   */
  passwordSetAt DateTime?

  /**
   * Tokens de ativação e recuperação de senha
   */
  passwordTokens PasswordResetToken[]

  /**
   * ✅ Vínculo com Owner (expositor).
   * Regra:
   * - role EXHIBITOR => ownerId obrigatório (validar no service)
   */
  ownerId String?
  owner   Owner?  @relation(fields: [ownerId], references: [id], onDelete: SetNull)

  fairsCreated             Fair[]             @relation("FairsCreated")
  auditLogs                AuditLog[]         @relation("UserAuditLogs")
  documentTemplatesCreated DocumentTemplate[] @relation("DocumentTemplatesCreatedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fairContractSettings                 FairContractSettings[]
  ownerFairPurchaseInstallmentPayments OwnerFairPurchaseInstallmentPayment[]
  ownerFairPurchaseAdjustments         OwnerFairPurchaseAdjustment[]

  @@index([ownerId])
  @@index([role])
  @@index([isActive])
}

model PasswordResetToken {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  /**
   * ✅ Hash do token (segurança).
   * Nunca armazenar o token puro no banco.
   */
  tokenHash String

  /**
   * ✅ Tipo do token: ativação ou reset.
   */
  type PasswordTokenType @default(RESET_PASSWORD)

  /**
   * Expiração curta (ex.: 30-60 minutos).
   */
  expiresAt DateTime

  /**
   * Uso único.
   */
  usedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@index([type])
}

// =====================
// MÓDULO DE FEIRAS
// =====================

model Fair {
  id     String     @id @default(uuid())
  name   String
  status FairStatus @default(ATIVA)

  /**
   * Endereço completo da feira.
   * Mantido como string única por enquanto.
   */
  address String

  /**
   * Capacidade total de barracas na feira.
   */
  stallsCapacity Int @default(0)

  createdByUserId String
  createdBy       User   @relation("FairsCreated", fields: [createdByUserId], references: [id])

  /**
   * Ocorrências (dias/horários) da feira.
   */
  occurrences FairOccurrence[]

  /**
   * Vínculos desta feira com expositores (Owner).
   */
  ownerFairs OwnerFair[]

  /**
   * Barracas vinculadas a esta feira.
   * Importante:
   * - Agora StallFair é a unidade de "compra/pagamento" por barraca.
   */
  stallFairs StallFair[]

  /**
   * ✅ Configuração do contrato principal da feira.
   */
  contractSettings FairContractSettings?

  taxes FairTax[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  fairMap   FairMap?

  @@index([createdByUserId])
}

model FairTax {
  id String @id @default(uuid())

  fairId String
  fair   Fair   @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * Nome da taxa.
   * Ex: "Taxa padrão", "Taxa carrinho", etc.
   */
  name String

  /**
   * Percentual em basis points.
   * 500 = 5.00%
   */
  percentBps Int

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases  OwnerFairPurchase[]
  stallFairs StallFair[]

  @@index([fairId])
}

model FairOccurrence {
  id     String @id @default(uuid())
  fairId String

  startsAt DateTime
  endsAt   DateTime

  fair Fair @relation(fields: [fairId], references: [id], onDelete: Cascade)

  @@unique([fairId, startsAt, endsAt])
  @@index([fairId, startsAt])
  @@index([startsAt, endsAt])
}

// =====================
// OWNER (EXPOSITOR)
// =====================

model Owner {
  id String @id @default(cuid())

  personType PersonType

  /**
   * Documento principal do expositor (CPF ou CNPJ),
   * sempre normalizado (somente dígitos) e único.
   */
  document String @unique

  fullName String?

  email String?
  phone String?

  addressFull    String?
  addressCity    String?
  addressState   String?
  addressZipcode String?
  addressNumber  String?

  pixKey          String?
  bankName        String?
  bankAgency      String?
  bankAccount     String?
  bankAccountType BankAccountType?

  bankHolderDoc  String?
  bankHolderName String?

  stallsDescription String?

  /**
   * Vínculos deste expositor com feiras (âncora).
   */
  fairs OwnerFair[]

  /**
   * Barracas cadastradas por este expositor.
   */
  stalls Stall[]

  /**
   * Usuários que podem acessar o portal por este expositor.
   */
  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([personType])
}

// =====================
// OWNER ↔ FAIR (ÂNCORA)
// =====================

model OwnerFair {
  id String @id @default(cuid())

  ownerId String
  fairId  String

  /**
   * ✅ Quantidade de barracas vinculadas/compradas para este expositor na feira.
   * Decisão:
   * - Continuamos persistindo por performance/UX.
   * - Fonte de verdade operacional: quantidade de StallFair vinculadas neste OwnerFair.
   * (no service você mantém isso sincronizado)
   */
  stallsQty Int @default(0)

  status OwnerFairStatus @default(SELECIONADO)

  /**
   * ✅ Marca que o contrato foi assinado (MVP).
   */
  contractSignedAt DateTime?

  owner Owner @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  fair  Fair  @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * ✅ Barracas vinculadas (cada uma com preço/pagamento próprios).
   */
  stallFairs StallFair[]

  /**
   * ✅ Contrato gerado para este expositor nesta feira.
   */
  contract Contract?

  /**
   * ✅ Aditivo opcional por expositor nesta feira.
   */
  addendum OwnerFairAddendum?

  /**
   * ✅ Observações internas do admin sobre este expositor nesta feira.
   * Ex.: "Vai ficar perto do palco", "Precisa chegar mais cedo", "Aguardando ajuste de pagamento", etc.
   */
  observations String?

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  ownerFairPurchases OwnerFairPurchase[]

  @@unique([ownerId, fairId])
  @@index([ownerId])
  @@index([fairId])
  @@index([status])
}

// =====================
// STALLS
// =====================

model Stall {
  id      String @id @default(cuid())
  ownerId String
  owner   Owner  @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  /**
   * Nome interno/PDV da barraca.
   * É exibido no painel/portal e também pode ser usado em etiquetas internas.
   */
  pdvName String

  /**
   * Versão normalizada para impedir duplicidade por Owner.
   * Ex.: "Pastel do Zé" => "pastel-do-ze"
   */
  pdvNameNormalized String

  /**
   * Quantidade de máquinas (fixo por barraca, não por feira).
   */
  machinesQty Int @default(0)

  /**
   * Nome do banner (opcional).
   */
  bannerName String?

  /**
   * Categoria principal (simples).
   * Obs.: categorias detalhadas ficam em StallMenuCategory/StallMenuProduct.
   */
  mainCategory String?

  /**
   * Tipo operacional da barraca.
   */
  stallType StallType @default(OPEN)

  /**
   * Tamanho (usado para validar vínculo com o que foi comprado no Admin).
   */
  stallSize StallSize @default(SIZE_3X3)

  /**
   * Quantidade de pessoas na equipe.
   */
  teamQty Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /**
   * Vínculos dessa barraca com feiras (quando o expositor "seleciona" para uma feira).
   */
  fairs StallFair[]

  /**
   * Cardápio / estrutura do menu.
   */
  menuCategories StallMenuCategory[]

  /**
   * Equipamentos e infraestrutura.
   */
  equipments StallEquipment[]
  powerNeed  StallPowerNeed?

  @@unique([ownerId, pdvNameNormalized])
  @@index([ownerId])
}

model StallFair {
  id String @id @default(cuid())

  stallId String
  fairId  String

  /**
   * Vínculo âncora do expositor na feira.
   * Importante: StallFair sempre pertence a um OwnerFair.
   */
  ownerFairId String
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  /**
   * Barraca real vinculada.
   */
  stall Stall @relation(fields: [stallId], references: [id], onDelete: Cascade)

  /**
   * Feira alvo do vínculo.
   */
  fair Fair @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * Compra específica que está sendo "consumida" por essa barraca vinculada.
   * Decisão de negócio:
   * - Cada StallFair consome exatamente 1 unidade de 1 OwnerFairPurchase.
   * - Por isso mantemos purchaseId obrigatório.
   * onDelete: Restrict evita apagar uma compra que já esteja em uso.
   */
  purchaseId String
  purchase   OwnerFairPurchase @relation(fields: [purchaseId], references: [id], onDelete: Restrict)

  /**
   * ✅ Taxa aplicada especificamente nesta barraca (na feira).
   * Regras:
   * - Uma barraca na feira só pode ter 1 taxa (taxId único no registro).
   * - A taxa deve pertencer à mesma feira (validar no service).
   * - Snapshot garante histórico contábil.
   */
  taxId String?
  tax   FairTax? @relation(fields: [taxId], references: [id], onDelete: Restrict)

  taxNameSnapshot       String?
  taxPercentBpsSnapshot Int?

  createdAt         DateTime           @default(now())
  fairMapBoothLinks FairMapBoothLink[]

  /**
   * Uma barraca não pode estar duas vezes na mesma feira.
   */
  @@unique([stallId, fairId])
  @@index([fairId])
  @@index([stallId])
  @@index([ownerFairId])
  @@index([purchaseId])
}

model OwnerFairPurchase {
  id String @id @default(cuid())

  ownerFairId String
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  /**
   * Tamanho comprado.
   * Regras do domínio:
   * - O Portal só pode vincular StallFair com stallSize compatível.
   */
  stallSize StallSize

  /**
   * Quantidade comprada.
   * ✅ Para o fluxo atual (Admin adiciona "1 por 1"), recomenda-se:
   * - qty = 1 sempre (validar no service)
   * Isso mantém o controle financeiro por linha e melhora rastreabilidade.
   */
  qty Int

  /**
   * Preço unitário em centavos.
   */
  unitPriceCents Int

  /**
   * Total da compra em centavos.
   * Regra: totalCents = qty * unitPriceCents (validar/calcular no service).
   */
  totalCents Int

  /**
   * Valor pago (entrada/sinal) em centavos.
   * Regra: 0 <= paidCents <= totalCents.
   */
  paidCents Int @default(0)

  /**
   * Momento em que ficou 100% pago (opcional).
   * Pode ser setado quando paidCents == totalCents.
   */
  paidAt DateTime?

  /**
   * Quantidade de parcelas do restante (0 se pago integralmente).
   * Regra: se (totalCents - paidCents) > 0 => installmentsCount > 0.
   */
  installmentsCount Int @default(0)

  /**
   * Status financeiro desta compra.
   * Deve ser recalculado no service conforme pago/vencimentos.
   */
  status OwnerFairPaymentStatus @default(PENDING)

  /**
   * Parcelas vinculadas a esta compra.
   * Cada compra tem seu "plano" de vencimentos/valores.
   */
  installments OwnerFairPurchaseInstallment[]

  /**
   * Quantidade já consumida por vínculos reais (StallFair).
   * Regras do domínio:
   * - usedQty <= qty
   * - Para o modelo "1 por 1", usedQty será 0 ou 1.
   */
  usedQty Int @default(0)

  /**
   * Barracas que estão consumindo esta compra.
   */
  stallFairs StallFair[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  fairTax   FairTax? @relation(fields: [fairTaxId], references: [id])
  fairTaxId String?

  adjustments OwnerFairPurchaseAdjustment[]

  /**
   * ✅ Removemos o @@unique para permitir múltiplas linhas,
   * mesmo com mesmo tamanho e preço.
   * Isso viabiliza controle financeiro 1 por 1 no Admin.
   */
  @@index([ownerFairId, stallSize])
  @@index([ownerFairId, stallSize, unitPriceCents])
  @@index([ownerFairId])
  @@index([stallSize])
  @@index([status])
}

model OwnerFairPurchaseAdjustment {
  id String @id @default(cuid())

  purchaseId String
  purchase   OwnerFairPurchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  /**
   * Valor do ajuste em centavos.
   * Regras:
   * - negativo = desconto
   * - positivo = acréscimo
   */
  amountCents Int

  /**
   * Motivo/observação do ajuste.
   */
  reason          String?
  type            AdjustmentType
  /**
   * Quem lançou (admin)
   */
  createdByUserId String
  createdBy       User           @relation(fields: [createdByUserId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  @@index([purchaseId])
  @@index([createdByUserId])
}

model OwnerFairPurchaseInstallment {
  id String @id @default(cuid())

  purchaseId String
  purchase   OwnerFairPurchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  /**
   * Número sequencial da parcela (1..N).
   */
  number Int

  /**
   * Data de vencimento da parcela.
   */
  dueDate DateTime

  /**
   * Valor da parcela em centavos.
   */
  amountCents Int

  /**
   * Preenchido quando a parcela for marcada como paga.
   */
  paidAt DateTime?

  /**
   * Caso exista pagamento parcial/diferente do previsto.
   */
  paidAmountCents Int?

  /**
   * Histórico de pagamentos desta parcela.
   * Fonte de verdade para pagamentos parciais.
   */
  payments OwnerFairPurchaseInstallmentPayment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /**
   * Uma compra não pode ter duas parcelas com o mesmo número.
   */
  @@unique([purchaseId, number])
  @@index([purchaseId])
  @@index([dueDate])
  @@index([paidAt])
}

model OwnerFairPurchaseInstallmentPayment {
  id String @id @default(cuid())

  installmentId String
  installment   OwnerFairPurchaseInstallment @relation(fields: [installmentId], references: [id], onDelete: Cascade)

  /**
   * Data/hora do pagamento registrado.
   * Obs.: no Admin podemos enviar date-only e normalizar pra 00:00Z.
   */
  paidAt DateTime

  /**
   * Valor pago em centavos neste pagamento.
   * Suporta pagamentos parciais (múltiplos registros por parcela).
   */
  amountCents Int

  /**
   * Opcional: observação do acordo (ex.: "negociação, prorrogado", "pix", etc).
   */
  note String?

  /**
   * Usuário admin que registrou o pagamento.
   * Restrict: não apagar usuário se houver histórico financeiro.
   */
  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  @@index([installmentId])
  @@index([paidAt])
  @@index([createdByUserId])
}

// =====================
// STALL MENU / INFRA
// =====================

model StallMenuCategory {
  id      String @id @default(cuid())
  stallId String
  stall   Stall  @relation(fields: [stallId], references: [id], onDelete: Cascade)

  name  String
  order Int    @default(0)

  products StallMenuProduct[]

  @@index([stallId])
}

model StallMenuProduct {
  id String @id @default(cuid())

  categoryId String
  category   StallMenuCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  name       String
  priceCents Int
  order      Int    @default(0)

  @@index([categoryId])
}

model StallEquipment {
  id      String @id @default(cuid())
  stallId String
  stall   Stall  @relation(fields: [stallId], references: [id], onDelete: Cascade)

  name String
  qty  Int    @default(1)

  @@index([stallId])
}

model StallPowerNeed {
  id      String @id @default(cuid())
  stallId String @unique
  stall   Stall  @relation(fields: [stallId], references: [id], onDelete: Cascade)

  outlets110   Int @default(0)
  outlets220   Int @default(0)
  outletsOther Int @default(0)

  needsGas Boolean @default(false)
  gasNotes String?

  notes String?
}

// =====================
// AUDITORIA
// =====================

model AuditLog {
  id String @id @default(uuid())

  action   AuditAction
  entity   AuditEntity
  entityId String

  actorUserId String
  actor       User   @relation("UserAuditLogs", fields: [actorUserId], references: [id], onDelete: Restrict)

  before Json?
  after  Json?
  meta   Json?

  createdAt DateTime @default(now())

  @@index([entity, entityId])
  @@index([actorUserId])
  @@index([createdAt])
}

// =====================
// CONTRATOS
// =====================

model DocumentTemplate {
  id String @id @default(uuid())

  title           String
  isAddendum      Boolean                @default(false)
  hasRegistration Boolean                @default(true)
  status          DocumentTemplateStatus @default(DRAFT)

  /**
   * Conteúdo do template (jsonb do editor).
   */
  content Json

  mainContracts     Contract[] @relation("ContractMainTemplate")
  addendumContracts Contract[] @relation("ContractAddendumTemplate")

  createdByUserId String?
  createdBy       User?   @relation("DocumentTemplatesCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  ownerFairAddendums OwnerFairAddendum[] @relation("OwnerFairAddendumTemplate")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fairContractSettings FairContractSettings[]

  @@index([status])
  @@index([isAddendum])
}

model FairContractSettings {
  id String @id @default(uuid())

  fairId String @unique
  fair   Fair   @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * Template principal (não-aditivo) usado pela feira.
   * Regra: deve ser isAddendum = false.
   */
  templateId String
  template   DocumentTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  updatedByUserId String?
  updatedBy       User?   @relation(fields: [updatedByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
}

model Contract {
  id String @id @default(uuid())

  ownerFairId String    @unique
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  templateId String
  template   DocumentTemplate @relation("ContractMainTemplate", fields: [templateId], references: [id], onDelete: Restrict)

  addendumTemplateId String?
  addendumTemplate   DocumentTemplate? @relation("ContractAddendumTemplate", fields: [addendumTemplateId], references: [id], onDelete: Restrict)

  pdfPath      String?
  dataSnapshot Json?

  // ✅ Assinafy
  assinafyDocumentId String?
  assinafySignerId   String?
  signUrl            String?
  signUrlExpiresAt   DateTime?

  signedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
  @@index([addendumTemplateId])
}

model OwnerFairAddendum {
  id String @id @default(uuid())

  ownerFairId String    @unique
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  /**
   * Template de aditivo (isAddendum = true).
   */
  templateId String
  template   DocumentTemplate @relation("OwnerFairAddendumTemplate", fields: [templateId], references: [id], onDelete: Restrict)

  /**
   * Versão do aditivo escolhida.
   */
  templateVersionNumber Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
}

model ExcelTemplate {
  id     String              @id @default(uuid())
  name   String
  status ExcelTemplateStatus @default(ACTIVE)

  scope ExcelTemplateScope @default(FAIR)

  /**
   * Abas que compõem o template.
   */
  sheets ExcelTemplateSheet[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

model ExcelTemplateSheet {
  id         String        @id @default(uuid())
  templateId String
  template   ExcelTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  /**
   * Nome da aba no Excel (ex.: "Relatório").
   */
  name String

  /**
   * Ordem de exibição das abas.
   */
  order Int @default(0)

  /**
   * Dataset base/contexto desta aba (para UI e validação).
   */
  dataset ExcelDataset

  /**
   * Células fixas (textos/binds).
   */
  cells ExcelTemplateCell[]

  /**
   * Tabelas dinâmicas (listas).
   */
  tables ExcelTemplateTable[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([templateId, name])
  @@index([templateId])
}

model ExcelTemplateCell {
  id      String             @id @default(uuid())
  sheetId String
  sheet   ExcelTemplateSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)

  /**
   * Linha/coluna no Excel (1-based).
   */
  row Int
  col Int

  /**
   * TEXT => value literal
   * BIND => value = fieldKey (ex.: "fair.name")
   */
  type  ExcelCellType
  value String

  /**
   * Formato opcional (se não informado, pode vir do catálogo).
   */
  format ExcelValueFormat?

  /**
   * Estilo mínimo MVP.
   */
  bold Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sheetId, row, col])
  @@index([sheetId])
}

model ExcelTemplateTable {
  id      String             @id @default(uuid())
  sheetId String
  sheet   ExcelTemplateSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)

  /**
   * Célula âncora onde a tabela começa (1-based).
   */
  anchorRow Int
  anchorCol Int

  /**
   * Dataset que será listado na tabela (ex.: FAIR_EXHIBITORS).
   */
  dataset ExcelDataset

  /**
   * Se true, escreve header na linha da âncora.
   */
  includeHeader Boolean @default(true)

  /**
   * Colunas configuráveis.
   */
  columns ExcelTemplateTableColumn[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sheetId])
}

model ExcelTemplateTableColumn {
  id      String             @id @default(uuid())
  tableId String
  table   ExcelTemplateTable @relation(fields: [tableId], references: [id], onDelete: Cascade)

  /**
   * Ordem de exibição da coluna (0..N).
   */
  order Int @default(0)

  /**
   * Texto do header (ex.: "Nome").
   */
  header String

  /**
   * Chave do campo (ex.: "owner.fullName").
   */
  fieldKey String

  /**
   * Formatação opcional.
   */
  format ExcelValueFormat?

  /**
   * Largura opcional da coluna (ExcelJS).
   */
  width Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tableId])
}

model MapTemplate {
  id          String  @id @default(cuid())
  title       String
  description String?

  /**
   * Apenas referência opcional para guiar o desenho.
   * Não fazemos upload nem "armazenamento"; é só uma string.
   * Pode ser uma URL pública, ou um path que você usa no front.
   */
  backgroundUrl String?

  /**
   * Dimensões do "mundo" do mapa, para o front saber o tamanho base.
   * O front fica responsivo via zoom/fit, mas o mundo é fixo.
   */
  worldWidth  Int @default(2000)
  worldHeight Int @default(1200)

  version Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  elements MapTemplateElement[]
  fairs    FairMap[]
}

model MapTemplateElement {
  id         String      @id @default(cuid())
  templateId String
  template   MapTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  /**
   * Chave estável gerada no front (ex.: "el_abcd").
   * IMPORTANTE pra manter os slots fixos e permitir vínculo por slotKey.
   */
  clientKey String

  type MapElementType

  // Transform base
  x        Float
  y        Float
  rotation Float @default(0)

  // Rect/slot
  width  Float?
  height Float?
  label  String?
  number Int? // útil em BOOTH_SLOT (ex.: 1,2,3...)

  // Line
  points Json? // [x1,y1,x2,y2,...]

  // Tree
  radius Float?

  // Style
  style Json

  /**
   * Marca o slot como linkável (somente BOOTH_SLOT deve ser true).
   * (Mantemos para validações extras e legibilidade.)
   */
  isLinkable Boolean @default(false)

  @@unique([templateId, clientKey])
  @@index([templateId])
}

model FairMap {
  id     String @id @default(cuid())
  fairId String @unique
  fair   Fair   @relation(fields: [fairId], references: [id], onDelete: Cascade)

  templateId String
  template   MapTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  /**
   * Versão aplicada (ajuda a entender se a planta mudou desde a vinculação).
   * Se você editar a planta, a feira "vê" a nova versão automaticamente,
   * mas podemos registrar qual versão estava quando vinculou.
   */
  templateVersionAtLink Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  links FairMapBoothLink[]
}

model FairMapBoothLink {
  id        String  @id @default(cuid())
  fairMapId String
  fairMap   FairMap @relation(fields: [fairMapId], references: [id], onDelete: Cascade)

  /**
   * O slot é identificado pelo clientKey do elemento BOOTH_SLOT na planta.
   * Isso permite reutilizar a planta em várias feiras.
   */
  slotClientKey String

  /**
   * Barraca vinculada à feira (financeiro/participação).
   * Só admins podem vincular.
   */
  stallFairId String
  stallFair   StallFair @relation(fields: [stallFairId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fairMapId, slotClientKey])
  @@unique([fairMapId, stallFairId]) // impede a mesma barraca em 2 slots
  @@index([stallFairId])
}
