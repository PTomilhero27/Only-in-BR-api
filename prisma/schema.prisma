datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// =====================
// ENUMS
// =====================

enum StallSize {
  SIZE_2X2
  SIZE_3X3
  SIZE_3X6
  TRAILER
}

enum StallType {
  OPEN
  CLOSED
  TRAILER
}

enum UserRole {
  ADMIN
  EXHIBITOR
}

enum FairStatus {
  ATIVA
  FINALIZADA
  CANCELADA
}

enum PersonType {
  PF
  PJ
}

enum BankAccountType {
  CORRENTE
  POUPANCA
  PAGAMENTO
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

enum AuditEntity {
  FAIR
  USER
  FORM
  FAIR_FORM
  CONTRACT
  PAYMENT
  OWNER_FAIR
  STALL_FAIR
  OWNER_FAIR_PURCHASE
  OWNER_FAIR_PURCHASE_PAYMENT
}

/**
 * Status operacional do expositor dentro da feira.
 * Obs.: continua existindo com contratos/pagamentos pois é útil no dashboard.
 */
enum OwnerFairStatus {
  SELECIONADO
  AGUARDANDO_PAGAMENTO
  AGUARDANDO_ASSINATURA
  AGUARDANDO_BARRACAS
  CONCLUIDO
}

/**
 * Status editorial do template de documento (contrato/aditivo).
 */
enum DocumentTemplateStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PasswordTokenType {
  ACTIVATE_ACCOUNT
  RESET_PASSWORD
}

enum OwnerFairPaymentStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

model User {
  id String @id @default(uuid())

  /**
   * Nome exibido do usuário.
   * Para EXHIBITOR pode ficar null (usamos Owner.fullName).
   */
  name String?

  /**
   * E-mail de login (único).
   */
  email String @unique

  /**
   * ✅ Hash da senha.
   * - null => conta ainda não ativada (aguardando definição de senha).
   */
  password String?

  /**
   * Papel principal.
   */
  role UserRole @default(ADMIN)

  /**
   * ✅ Permite admin desativar o acesso sem deletar.
   */
  isActive Boolean @default(true)

  /**
   * ✅ Quando a senha foi definida (ativação concluída).
   */
  passwordSetAt DateTime?

  /**
   * Tokens de ativação e recuperação de senha
   */
  passwordTokens PasswordResetToken[]

  /**
   * ✅ Vínculo com Owner (expositor).
   * Regra:
   * - role EXHIBITOR => ownerId obrigatório (validar no service)
   */
  ownerId String?
  owner   Owner?  @relation(fields: [ownerId], references: [id], onDelete: SetNull)

  fairsCreated             Fair[]             @relation("FairsCreated")
  auditLogs                AuditLog[]         @relation("UserAuditLogs")
  documentTemplatesCreated DocumentTemplate[] @relation("DocumentTemplatesCreatedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fairContractSettings                 FairContractSettings[]
  ownerFairPurchaseInstallmentPayments OwnerFairPurchaseInstallmentPayment[]

  @@index([ownerId])
  @@index([role])
  @@index([isActive])
}

model PasswordResetToken {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  /**
   * ✅ Hash do token (segurança).
   * Nunca armazenar o token puro no banco.
   */
  tokenHash String

  /**
   * ✅ Tipo do token: ativação ou reset.
   */
  type PasswordTokenType @default(RESET_PASSWORD)

  /**
   * Expiração curta (ex.: 30-60 minutos).
   */
  expiresAt DateTime

  /**
   * Uso único.
   */
  usedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@index([type])
}

// =====================
// MÓDULO DE FEIRAS
// =====================

model Fair {
  id     String     @id @default(uuid())
  name   String
  status FairStatus @default(ATIVA)

  /**
   * Endereço completo da feira.
   * Mantido como string única por enquanto.
   */
  address String

  /**
   * Capacidade total de barracas na feira.
   */
  stallsCapacity Int @default(0)

  createdByUserId String
  createdBy       User   @relation("FairsCreated", fields: [createdByUserId], references: [id])

  /**
   * Ocorrências (dias/horários) da feira.
   */
  occurrences FairOccurrence[]

  /**
   * Vínculos desta feira com expositores (Owner).
   */
  ownerFairs OwnerFair[]

  /**
   * Vínculos desta feira com formulários.
   */
  fairForms FairForm[]

  /**
   * Barracas vinculadas a esta feira.
   * Importante:
   * - Agora StallFair é a unidade de "compra/pagamento" por barraca.
   */
  stallFairs StallFair[]

  /**
   * ✅ Configuração do contrato principal da feira.
   */
  contractSettings FairContractSettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdByUserId])
}

model FairOccurrence {
  id     String @id @default(uuid())
  fairId String

  startsAt DateTime
  endsAt   DateTime

  fair Fair @relation(fields: [fairId], references: [id], onDelete: Cascade)

  @@unique([fairId, startsAt, endsAt])
  @@index([fairId, startsAt])
  @@index([startsAt, endsAt])
}

model Form {
  id String @id @default(cuid())

  /**
   * Identificador lógico do formulário.
   * Ex.: "stalls", "interests", "contracts"
   */
  slug String @unique

  /**
   * Nome exibido no painel admin.
   */
  name String

  /**
   * Permite desativar o form globalmente.
   */
  active Boolean @default(true)

  /**
   * Vínculos deste formulário com feiras.
   */
  fairForms FairForm[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FairForm {
  id String @id @default(cuid())

  fairId String
  formId String

  /**
   * Ativa/desativa rapidamente o form para esta feira.
   */
  enabled Boolean @default(false)

  /**
   * Janela de liberação do formulário.
   */
  startsAt DateTime
  endsAt   DateTime

  fair Fair @relation(fields: [fairId], references: [id], onDelete: Cascade)
  form Form @relation(fields: [formId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fairId, formId])
  @@index([fairId])
  @@index([formId])
}

// =====================
// OWNER (EXPOSITOR)
// =====================

model Owner {
  id String @id @default(cuid())

  personType PersonType

  /**
   * Documento principal do expositor (CPF ou CNPJ),
   * sempre normalizado (somente dígitos) e único.
   */
  document String @unique

  fullName String?

  email String?
  phone String?

  addressFull    String?
  addressCity    String?
  addressState   String?
  addressZipcode String?
  addressNumber  String?

  pixKey          String?
  bankName        String?
  bankAgency      String?
  bankAccount     String?
  bankAccountType BankAccountType?

  bankHolderDoc  String?
  bankHolderName String?

  stallsDescription String?

  /**
   * Vínculos deste expositor com feiras (âncora).
   */
  fairs OwnerFair[]

  /**
   * Barracas cadastradas por este expositor.
   */
  stalls Stall[]

  /**
   * Usuários que podem acessar o portal por este expositor.
   */
  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([personType])
}

// =====================
// OWNER ↔ FAIR (ÂNCORA)
// =====================

model OwnerFair {
  id String @id @default(cuid())

  ownerId String
  fairId  String

  /**
   * ✅ Quantidade de barracas vinculadas/compradas para este expositor na feira.
   * Decisão:
   * - Continuamos persistindo por performance/UX.
   * - Fonte de verdade operacional: quantidade de StallFair vinculadas neste OwnerFair.
   * (no service você mantém isso sincronizado)
   */
  stallsQty Int @default(0)

  status OwnerFairStatus @default(SELECIONADO)

  /**
   * ✅ Marca que o contrato foi assinado (MVP).
   */
  contractSignedAt DateTime?

  owner Owner @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  fair  Fair  @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * ✅ Barracas vinculadas (cada uma com preço/pagamento próprios).
   */
  stallFairs StallFair[]

  /**
   * ✅ Contrato gerado para este expositor nesta feira.
   */
  contract Contract?

  /**
   * ✅ Aditivo opcional por expositor nesta feira.
   */
  addendum OwnerFairAddendum?

  /**
   * ✅ Observações internas do admin sobre este expositor nesta feira.
   * Ex.: "Vai ficar perto do palco", "Precisa chegar mais cedo", "Aguardando ajuste de pagamento", etc.
   */
  observations String?

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  ownerFairPurchases OwnerFairPurchase[]

  @@unique([ownerId, fairId])
  @@index([ownerId])
  @@index([fairId])
  @@index([status])
}

// =====================
// STALLS
// =====================

model Stall {
  id      String @id @default(cuid())
  ownerId String
  owner   Owner  @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  /**
   * Nome interno/PDV da barraca.
   * É exibido no painel/portal e também pode ser usado em etiquetas internas.
   */
  pdvName String

  /**
   * Versão normalizada para impedir duplicidade por Owner.
   * Ex.: "Pastel do Zé" => "pastel-do-ze"
   */
  pdvNameNormalized String

  /**
   * Quantidade de máquinas (fixo por barraca, não por feira).
   */
  machinesQty Int @default(0)

  /**
   * Nome do banner (opcional).
   */
  bannerName String?

  /**
   * Categoria principal (simples).
   * Obs.: categorias detalhadas ficam em StallMenuCategory/StallMenuProduct.
   */
  mainCategory String?

  /**
   * Tipo operacional da barraca.
   */
  stallType StallType @default(OPEN)

  /**
   * Tamanho (usado para validar vínculo com o que foi comprado no Admin).
   */
  stallSize StallSize @default(SIZE_3X3)

  /**
   * Quantidade de pessoas na equipe.
   */
  teamQty Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /**
   * Vínculos dessa barraca com feiras (quando o expositor "seleciona" para uma feira).
   */
  fairs StallFair[]

  /**
   * Cardápio / estrutura do menu.
   */
  menuCategories StallMenuCategory[]

  /**
   * Equipamentos e infraestrutura.
   */
  equipments StallEquipment[]
  powerNeed  StallPowerNeed?

  @@unique([ownerId, pdvNameNormalized])
  @@index([ownerId])
}

model StallFair {
  id String @id @default(cuid())

  stallId String
  fairId  String

  /**
   * Vínculo âncora do expositor na feira.
   * Importante: StallFair sempre pertence a um OwnerFair.
   */
  ownerFairId String
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  /**
   * Barraca real vinculada.
   */
  stall Stall @relation(fields: [stallId], references: [id], onDelete: Cascade)

  /**
   * Feira alvo do vínculo.
   */
  fair Fair @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * Compra específica que está sendo "consumida" por essa barraca vinculada.
   * Decisão de negócio:
   * - Cada StallFair consome exatamente 1 unidade de 1 OwnerFairPurchase.
   * - Por isso mantemos purchaseId obrigatório.
   * onDelete: Restrict evita apagar uma compra que já esteja em uso.
   */
  purchaseId String
  purchase   OwnerFairPurchase @relation(fields: [purchaseId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  /**
   * Uma barraca não pode estar duas vezes na mesma feira.
   */
  @@unique([stallId, fairId])
  @@index([fairId])
  @@index([stallId])
  @@index([ownerFairId])
  @@index([purchaseId])
}

model OwnerFairPurchase {
  id String @id @default(cuid())

  ownerFairId String
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  /**
   * Tamanho comprado.
   * Regras do domínio:
   * - O Portal só pode vincular StallFair com stallSize compatível.
   */
  stallSize StallSize

  /**
   * Quantidade comprada.
   * ✅ Para o fluxo atual (Admin adiciona "1 por 1"), recomenda-se:
   * - qty = 1 sempre (validar no service)
   * Isso mantém o controle financeiro por linha e melhora rastreabilidade.
   */
  qty Int

  /**
   * Preço unitário em centavos.
   */
  unitPriceCents Int

  /**
   * Total da compra em centavos.
   * Regra: totalCents = qty * unitPriceCents (validar/calcular no service).
   */
  totalCents Int

  /**
   * Valor pago (entrada/sinal) em centavos.
   * Regra: 0 <= paidCents <= totalCents.
   */
  paidCents Int @default(0)

  /**
   * Momento em que ficou 100% pago (opcional).
   * Pode ser setado quando paidCents == totalCents.
   */
  paidAt DateTime?

  /**
   * Quantidade de parcelas do restante (0 se pago integralmente).
   * Regra: se (totalCents - paidCents) > 0 => installmentsCount > 0.
   */
  installmentsCount Int @default(0)

  /**
   * Status financeiro desta compra.
   * Deve ser recalculado no service conforme pago/vencimentos.
   */
  status OwnerFairPaymentStatus @default(PENDING)

  /**
   * Parcelas vinculadas a esta compra.
   * Cada compra tem seu "plano" de vencimentos/valores.
   */
  installments OwnerFairPurchaseInstallment[]

  /**
   * Quantidade já consumida por vínculos reais (StallFair).
   * Regras do domínio:
   * - usedQty <= qty
   * - Para o modelo "1 por 1", usedQty será 0 ou 1.
   */
  usedQty Int @default(0)

  /**
   * Barracas que estão consumindo esta compra.
   */
  stallFairs StallFair[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /**
   * ✅ Removemos o @@unique para permitir múltiplas linhas,
   * mesmo com mesmo tamanho e preço.
   * Isso viabiliza controle financeiro 1 por 1 no Admin.
   */
  @@index([ownerFairId, stallSize])
  @@index([ownerFairId, stallSize, unitPriceCents])
  @@index([ownerFairId])
  @@index([stallSize])
  @@index([status])
}

model OwnerFairPurchaseInstallment {
  id String @id @default(cuid())

  purchaseId String
  purchase   OwnerFairPurchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  /**
   * Número sequencial da parcela (1..N).
   */
  number Int

  /**
   * Data de vencimento da parcela.
   */
  dueDate DateTime

  /**
   * Valor da parcela em centavos.
   */
  amountCents Int

  /**
   * Preenchido quando a parcela for marcada como paga.
   */
  paidAt DateTime?

  /**
   * Caso exista pagamento parcial/diferente do previsto.
   */
  paidAmountCents Int?

  /**
   * Histórico de pagamentos desta parcela.
   * Fonte de verdade para pagamentos parciais.
   */
  payments OwnerFairPurchaseInstallmentPayment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /**
   * Uma compra não pode ter duas parcelas com o mesmo número.
   */
  @@unique([purchaseId, number])
  @@index([purchaseId])
  @@index([dueDate])
  @@index([paidAt])
}

model OwnerFairPurchaseInstallmentPayment {
  id String @id @default(cuid())

  installmentId String
  installment   OwnerFairPurchaseInstallment @relation(fields: [installmentId], references: [id], onDelete: Cascade)

  /**
   * Data/hora do pagamento registrado.
   * Obs.: no Admin podemos enviar date-only e normalizar pra 00:00Z.
   */
  paidAt DateTime

  /**
   * Valor pago em centavos neste pagamento.
   * Suporta pagamentos parciais (múltiplos registros por parcela).
   */
  amountCents Int

  /**
   * Opcional: observação do acordo (ex.: "negociação, prorrogado", "pix", etc).
   */
  note String?

  /**
   * Usuário admin que registrou o pagamento.
   * Restrict: não apagar usuário se houver histórico financeiro.
   */
  createdByUserId String
  createdBy       User   @relation(fields: [createdByUserId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  @@index([installmentId])
  @@index([paidAt])
  @@index([createdByUserId])
}

// =====================
// STALL MENU / INFRA
// =====================

model StallMenuCategory {
  id      String @id @default(cuid())
  stallId String
  stall   Stall  @relation(fields: [stallId], references: [id], onDelete: Cascade)

  name  String
  order Int    @default(0)

  products StallMenuProduct[]

  @@index([stallId])
}

model StallMenuProduct {
  id String @id @default(cuid())

  categoryId String
  category   StallMenuCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  name       String
  priceCents Int
  order      Int    @default(0)

  @@index([categoryId])
}

model StallEquipment {
  id      String @id @default(cuid())
  stallId String
  stall   Stall  @relation(fields: [stallId], references: [id], onDelete: Cascade)

  name String
  qty  Int    @default(1)

  @@index([stallId])
}

model StallPowerNeed {
  id      String @id @default(cuid())
  stallId String @unique
  stall   Stall  @relation(fields: [stallId], references: [id], onDelete: Cascade)

  outlets110   Int @default(0)
  outlets220   Int @default(0)
  outletsOther Int @default(0)

  needsGas Boolean @default(false)
  gasNotes String?

  notes String?
}

// =====================
// AUDITORIA
// =====================

model AuditLog {
  id String @id @default(uuid())

  action   AuditAction
  entity   AuditEntity
  entityId String

  actorUserId String
  actor       User   @relation("UserAuditLogs", fields: [actorUserId], references: [id], onDelete: Restrict)

  before Json?
  after  Json?
  meta   Json?

  createdAt DateTime @default(now())

  @@index([entity, entityId])
  @@index([actorUserId])
  @@index([createdAt])
}

// =====================
// CONTRATOS
// =====================

model DocumentTemplate {
  id String @id @default(uuid())

  title           String
  isAddendum      Boolean                @default(false)
  hasRegistration Boolean                @default(true)
  status          DocumentTemplateStatus @default(DRAFT)

  /**
   * Conteúdo do template (jsonb do editor).
   */
  content Json

  mainContracts     Contract[] @relation("ContractMainTemplate")
  addendumContracts Contract[] @relation("ContractAddendumTemplate")

  createdByUserId String?
  createdBy       User?   @relation("DocumentTemplatesCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  ownerFairAddendums OwnerFairAddendum[] @relation("OwnerFairAddendumTemplate")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fairContractSettings FairContractSettings[]

  @@index([status])
  @@index([isAddendum])
}

model FairContractSettings {
  id String @id @default(uuid())

  fairId String @unique
  fair   Fair   @relation(fields: [fairId], references: [id], onDelete: Cascade)

  /**
   * Template principal (não-aditivo) usado pela feira.
   * Regra: deve ser isAddendum = false.
   */
  templateId String
  template   DocumentTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  updatedByUserId String?
  updatedBy       User?   @relation(fields: [updatedByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
}

model Contract {
  id String @id @default(uuid())

  ownerFairId String    @unique
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  templateId String
  template   DocumentTemplate @relation("ContractMainTemplate", fields: [templateId], references: [id], onDelete: Restrict)

  addendumTemplateId String?
  addendumTemplate   DocumentTemplate? @relation("ContractAddendumTemplate", fields: [addendumTemplateId], references: [id], onDelete: Restrict)

  pdfPath      String?
  dataSnapshot Json?

  // ✅ Assinafy
  assinafyDocumentId String?
  assinafySignerId   String?
  signUrl            String?
  signUrlExpiresAt   DateTime?

  signedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
  @@index([addendumTemplateId])
}

model OwnerFairAddendum {
  id String @id @default(uuid())

  ownerFairId String    @unique
  ownerFair   OwnerFair @relation(fields: [ownerFairId], references: [id], onDelete: Cascade)

  /**
   * Template de aditivo (isAddendum = true).
   */
  templateId String
  template   DocumentTemplate @relation("OwnerFairAddendumTemplate", fields: [templateId], references: [id], onDelete: Restrict)

  /**
   * Versão do aditivo escolhida.
   */
  templateVersionNumber Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([templateId])
}
